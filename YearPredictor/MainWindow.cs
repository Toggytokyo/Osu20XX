using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.IO;
using System.IO.Compression;
using System.Text.RegularExpressions;
using Osu20XXML.Model;

namespace Osu20XXML.WindowsForm
{
    public partial class MainWindow : Form
    {
        #region Variables

        //MapPanel storage
        readonly int MAPS_PER_PAGE = 6; 
        private int currentPage = 0;
        private List<MapPanel> displayedMaps = new List<MapPanel>();
        private List<MapInfo> allMaps = new List<MapInfo>();
        string[] searchTerms = { "" };

        //State variables
        bool currentlyLoading = false;

        #endregion


        #region Windows Form Functions


        #region Misc

        //The following function headers are generated by visual studio.
        //Overall functionality should be obvious based on function names.

        public MainWindow()
        {
            InitializeComponent();
        }

        private void Form1_Load(object sender, EventArgs e)
        {

        }

        private void fileLoader_DoWork(object sender, DoWorkEventArgs e)
        {
            //Call LoadFiles func and wait
            BackgroundWorker worker = sender as BackgroundWorker;

            LoadFiles((string[])e.Argument, worker, e);
        }

        private void fileLoader_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            //Update UI
            UpdateMapList();
            fileLoadingProgressBar.Visible = false;
        }

        private void fileLoader_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            fileLoadingProgressBar.Value = e.ProgressPercentage;
        }

        private void rightPageButton_Click(object sender, EventArgs e)
        {
            if (currentPage < (int)Math.Ceiling((float)allMaps.Count / MAPS_PER_PAGE) - 1) //Make sure there is a page we can move to
            {
                currentPage++;
                UpdateMapList();
            }
        }

        private void leftPageButton_Click(object sender, EventArgs e) 
        {
            if (currentPage > 0) //Make sure there is a page we can move to
            {
                currentPage--;
                UpdateMapList();
            }
        }

        private void clearButton_Click(object sender, EventArgs e)
        {
            allMaps.Clear();
            UpdateMapList();
        }

        private void pageLabel_TextChanged(object sender, EventArgs e)
        {
            if (PageLabel.Enabled == false) //Stops the function from entering an infinite loop when updated
                return;

            int input;
            if (int.TryParse(PageLabel.Text.Split('/')[0], out input)) //Get the page we want
            {
                if (input > 0 && input <= (int)Math.Ceiling((float)allMaps.Count / MAPS_PER_PAGE)) //Make sure the page is valid
                {
                    currentPage = input - 1;
                    UpdateMapList();
                    return;
                }
            }

            //If anything fails, set page to 0
            currentPage = 0;
            UpdateMapList();
        }

        private void searchBox_TextChanged(object sender, EventArgs e)
        {
            searchTerms = SearchBox.Text.Split(' ');
            UpdateMapList();
        }


        #endregion


        #region Drop Panel

        //The following function headers are generated by visual studio.
        //Overall functionality should be obvious based on function names.

        private void DropPanel_DragEnter(object sender, DragEventArgs e)
        {
            if (currentlyLoading)
                return;

            if (e.Data.GetDataPresent(DataFormats.FileDrop)) //Check that we have data
            {
                if (CheckFileTypes(e.Data.GetData(DataFormats.FileDrop) as string[])) //Check that the data is what we want
                {
                    e.Effect = DragDropEffects.Copy;
                    DropPanel.BackColor = Color.PaleGreen;
                }
                else  //The data is not what we want
                {
                    e.Effect = DragDropEffects.None;
                    DropPanel.BackColor = Color.PaleVioletRed;
                }
            }
            else //There is no data
            {
                DropPanel.BackColor = Color.PaleVioletRed;
                e.Effect = DragDropEffects.None;
            }
        }
        
        private void DropPanel_DragLeave(object sender, EventArgs e)
        {
            if (currentlyLoading)
                return;

            DropPanel.BackColor = Color.LightSlateGray;
        }

        private void DropPanel_Click(object sender, EventArgs e)
        {
            if (currentlyLoading)
                return;

            //Open a file dialog so the user can choose files that they want to open
            if (fileDialog.ShowDialog() == DialogResult.OK)
            {
                //Get the path of specified file
                string[] filePaths = fileDialog.FileNames;
                fileLoadingProgressBar.Visible = true;
                fileLoadingProgressBar.Value = 0;
                DropPanel.BackColor = Color.PaleVioletRed;
                fileLoader.RunWorkerAsync(filePaths);
            }
        }

        private void DropLabel_Click(object sender, EventArgs e)
        {
            if (currentlyLoading)
                return;

            DropPanel_Click(sender, e);
        }

        private void DropPanel_DragDrop(object sender, DragEventArgs e)
        {
            if (currentlyLoading)
                return;

            if (CheckFileTypes(e.Data.GetData(DataFormats.FileDrop) as string[])) //Double check we have the data we want
            {
                //Start loading the files 
                fileLoadingProgressBar.Visible = true;
                fileLoadingProgressBar.Value = 0;
                DropPanel.BackColor = Color.PaleVioletRed;
                fileLoader.RunWorkerAsync(e.Data.GetData(DataFormats.FileDrop) as string[]);
            }
        }

        #endregion


        #endregion


        #region Utility Functions

        /// <summary>
        /// Returns true if every map provided is a .osu or .osz file. Returns false if otherwise.
        /// </summary>
        /// <param name="filePaths"> The files being checked </param>
        /// <returns></returns>
        private bool CheckFileTypes(string[] filePaths)
        {
            foreach (string path in filePaths)
                if (!(path.EndsWith(".osz") || path.EndsWith(".osu")))
                    return false;
            return true;
        }

        /// <summary>
        /// Deletes a map from the associatedMapInfo container.
        /// </summary>
        /// <param name="map"> The map to be deleted </param>
        public void DeleteMap(MapPanel map)
        {
            allMaps.Remove(map.associatedMapInfo);
            UpdateMapList();
        }

        public void DeselectMaps(MapPanel selectedMap)
        {
            foreach(MapPanel map in displayedMaps)
                if(map != selectedMap)
                    map.Deselect();
        }

        /// <summary>
        /// Sends a map to the ML model to be evaluated and updates the YearLabel accordingly.
        /// </summary>
        /// <param name="mapInfo"> The map to be evaluated </param>
        public void EvaluateMap(MapInfo mapInfo)
        {
            var predictedYear = ConsumeModel.Predict(mapInfo.ConvertToModelInput());
            YearLabel.Text = predictedYear.Prediction;
        }

        /// <summary>
        /// Test function for a map. A map will be marked as 'found' (function will return true) if any of its features contain at least a part of every search term.
        /// </summary>
        /// <param name="map"> The map being tested </param>
        /// <returns></returns>
        private bool FindMaps(MapInfo map)
        {
            foreach(string term in searchTerms)
            {
                if (!(map.MapName.ToLower().Contains(term.ToLower())
                    || map.DiffName.ToLower().Contains(term.ToLower())
                    || map.ArtistName.ToLower().Contains(term.ToLower())
                    || map.CreatorName.ToLower().Contains(term.ToLower())))
                    return false;
            }
            return true;
        }

        /// <summary>
        /// Function to load files from the given  filepaths with a BackgroundWorker
        /// </summary>
        /// <param name="filePaths"> Files to load </param>
        /// <param name="worker"> Worker object </param>
        /// <param name="e"> Event object </param>
        private void LoadFiles(string[] filePaths, BackgroundWorker worker, DoWorkEventArgs e)
        {
            //Disable the file selector while we are loading files
            currentlyLoading = true;

            
            
            //Check to make sure that the given file paths are .osu  and .osz
            if (CheckFileTypes(filePaths))
            {
                //Starting load loop
                int count = 0;
                worker.ReportProgress(0);

                foreach (string path in filePaths)
                {
                    //If the file is .osz, we treat it like a .zip
                    if (path.EndsWith(".osz"))
                    {
                        //Unzip...
                        using (ZipArchive archive = ZipFile.OpenRead(path))
                        {
                            //Go through each file in the archive
                            foreach (ZipArchiveEntry entry in archive.Entries)
                            {
                                //Find the .osu files we need
                                if (entry.FullName.EndsWith(".osu", StringComparison.OrdinalIgnoreCase))
                                {
                                    ReadOsuFile(new StreamReader(entry.Open()));
                                }
                            }
                        }
                    }

                    //If the given file is just a .osu file, we can just read it in
                    else if (path.EndsWith(".osu"))
                    {
                        ReadOsuFile(File.OpenText(path));
                    }
                    count++;
                    worker.ReportProgress((int)(((float)count /(float)filePaths.Length) * 100));
                }
            }

            currentlyLoading = false;
            DropPanel.BackColor = Color.LightSlateGray;
        }

        /// <summary>
        /// Returns the smaller of the two inputs
        /// </summary>
        /// <param name="a"> First input </param>
        /// <param name="b"> Second input </param>
        /// <returns></returns>
        private float Minimum(float a, float b)
        {
            if (a < b)
                return a;
            return b;
        }

        /// <summary>
        /// Reads a .osu file stream and adds its representation to the MapPanel list
        /// </summary>
        /// <param name="sr"> .osu file's file stream </param>
        private void ReadOsuFile(StreamReader sr)
        {
            //Initializing a new MapInfo container and loading in the metadata from the .osu file
            //Its faster to read the entire map into a string and run regex checks
            MapInfo newMap = new MapInfo();
            List<float> deltaTimes = new List<float>();
            List<float> diffs = new List<float>();

            //Read metadata into fileText string
            string fileText = sr.ReadToEnd();
            string[] metadata = fileText.Split("[HitObjects]");

            /*
            string line = null;
            while (!(line = sr.ReadLine()).Contains("[HitObjects]"))
            {
                fileText += line + "\n";
            }
            while ((line = sr.ReadLine()) != null)
            {
                objectText += line + "\n";
            }
            */
            //Read the hitobjects and generate related data points
            float last_x = float.MinValue;
            float last_y = float.MinValue;
            float last_time = float.MinValue;

            MatchCollection objectMatch = Regex.Matches(metadata[1], @"(\d+\.?\d*),(\d+\.?\d*),(\d+\.?\d*).*");
            

            foreach (Match obj in objectMatch)
            {
                float x = float.Parse(obj.Groups[1].Value);
                float y = float.Parse(obj.Groups[2].Value);
                float time = float.Parse(obj.Groups[3].Value);
                if (last_x != float.MinValue && last_y != float.MinValue && last_time != float.MinValue)
                {
                    float distance = (float)Math.Sqrt(Math.Pow(x - last_x, 2) + Math.Pow(y - last_y, 2));
                    float deltaTime = time - last_time;
                    if (deltaTime != 0)
                        diffs.Add(distance / deltaTime);
                    deltaTimes.Add(deltaTime);
                }
                last_x = x;
                last_y = y;
                last_time = time;
            }
            
            newMap.AvgDeltaTime = Enumerable.Average(deltaTimes);
            newMap.StddevDeltaTime = (float)Math.Sqrt(deltaTimes.Average(v => Math.Pow(v - newMap.AvgDeltaTime, 2)));
            float diffAverage = Enumerable.Average(diffs);
            newMap.DiffVariance = (float)Math.Sqrt(diffs.Average(v => Math.Pow(v - diffAverage, 2))) / diffAverage;
            Match rxMatch;

            //Perform regex matches on fileText

            rxMatch = Regex.Match(metadata[0], @"(Title:)(.+)");
            if (rxMatch.Success)
            {
                newMap.MapName = rxMatch.Groups[2].Value;
            }

            rxMatch = Regex.Match(metadata[0], @"(Version:)(.+)");
            if (rxMatch.Success)
            {
                newMap.DiffName = rxMatch.Groups[2].Value;
            }

            rxMatch = Regex.Match(metadata[0], @"(Artist:)(.+)");
            if (rxMatch.Success)
            {
                newMap.ArtistName = rxMatch.Groups[2].Value;
            }

            rxMatch = Regex.Match(metadata[0], @"(Creator:)(.+)");
            if (rxMatch.Success)
            {
                newMap.CreatorName = rxMatch.Groups[2].Value;
            }

            rxMatch = Regex.Match(metadata[0], @"(HPDrainRate:)(\d*.?\d*)");
            if (rxMatch.Success)
            {
                newMap.Hp = float.Parse(rxMatch.Groups[2].Value);
            }

            rxMatch = Regex.Match(metadata[0], @"(CircleSize:)(\d*.?\d*)");
            if (rxMatch.Success)
            {
                newMap.Cs = float.Parse(rxMatch.Groups[2].Value);
            }

            rxMatch = Regex.Match(metadata[0], @"(OverallDifficulty:)(\d*.?\d*)");
            if (rxMatch.Success)
            {
                newMap.Od = float.Parse(rxMatch.Groups[2].Value);
            }

            rxMatch = Regex.Match(metadata[0], @"(ApproachRate:)(\d*.?\d*)");
            if (rxMatch.Success)
            {
                newMap.Ar = float.Parse(rxMatch.Groups[2].Value);
            }
            else
            {
                newMap.Ar = newMap.Od;
            }

            //Create a new MapPanel and add it to our list of MapPanels
            allMaps.Add(newMap);
        }

        /// <summary>
        /// Updates the maps that are being displayed based on the loaded maps and current search terms.
        /// </summary>
        public void UpdateMapList()
        {
            //Filtering the maps based on the search terms
            List<MapInfo> filteredMaps = new List<MapInfo>();
            filteredMaps = allMaps.FindAll(FindMaps);

            //Making sure we are on a proper page
            if (currentPage * MAPS_PER_PAGE >= filteredMaps.Count && currentPage > 0)
                currentPage--;

            //Check if we need to display the label saying that maps will appear here 
            if (allMaps.Count > 0) {
                PageLabel.Text = (currentPage + 1).ToString() + "/" + ((int)Math.Ceiling((float)filteredMaps.Count / MAPS_PER_PAGE)).ToString();
                MapsLabel.Visible = false;
                if (filteredMaps.Count > 0)
                {
                    PageLabel.Enabled = true;
                    PageLabel.Text = (currentPage + 1).ToString() + "/" + ((int)Math.Ceiling((float)filteredMaps.Count / MAPS_PER_PAGE)).ToString();
                    noResultsLabel.Visible = false;
                }
                else //No search results where found
                {
                    PageLabel.Enabled = false;
                    PageLabel.Text = "0/0";
                    noResultsLabel.Visible = true;
                }
            }               
            else //No maps are loaded
            {
                
                PageLabel.Enabled = false;
                noResultsLabel.Visible = false;
                MapsLabel.Visible = true;
                PageLabel.Text = "0/0";
            }

            
            //Sort the maps into alphabetical order
            filteredMaps.Sort((m1, m2) => m1.MapName.CompareTo(m2.MapName));

            //Clear our currently displayed maps 
            foreach(MapPanel map in displayedMaps)
            {
                map.Dispose();
            }
            displayedMaps.Clear();

            //Display our new maps
            if (allMaps.Count > 0)
            {
                int count = 0;
                foreach (MapInfo map in filteredMaps.GetRange(currentPage * MAPS_PER_PAGE, (int)Minimum((filteredMaps.Count - currentPage * MAPS_PER_PAGE), MAPS_PER_PAGE)))
                {
                    MapPanel newDisplayedMap = new MapPanel(map, count, this);
                    displayedMaps.Add(newDisplayedMap);
                    MapPanel.Controls.Add(newDisplayedMap);
                    count++;
                }
            }

        }

        #endregion

    }
}
